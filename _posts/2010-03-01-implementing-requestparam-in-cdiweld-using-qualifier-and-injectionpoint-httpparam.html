---
layout: post
title: Implementing @RequestParam in CDI/WELD using Qualifier and InjectionPoint as
  @HttpParam
tags:
- cdi
- Java
- JavaEE
- weld
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _jd_tweet_this: ''
  _jd_twitter: ''
  _wp_jd_clig: ''
  _wp_jd_bitly: ''
  _wp_jd_wp: ''
  _wp_jd_yourls: ''
  _wp_jd_url: ''
  _wp_jd_target: ''
  _jd_wp_twitter: ''
  _jd_post_meta_fixed: 'true'
---
Implementing @RequestParam as @HttpParam is quite easy. This is the example discussed in the <a href="http://docs.jboss.org/weld/reference/1.0.1-Final/en-US/html_single/#d0e1622">Weld Reference Documentation</a>. What we do is set up a <a href="http://docs.jboss.org/weld/reference/1.0.1-Final/en-US/html_single/#d0e1212">Qualifier</a> like this:
[code lang="java"]
@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface HttpParam {
    public String value() default &quot;&quot;;
}
[/code]
Then all we need to do is create a <a href="http://docs.jboss.org/weld/reference/1.0.1-Final/en-US/html_single/#d0e942">Producer Method</a>: and utilize the <a href="http://docs.jboss.org/weld/reference/1.0.1-Final/en-US/html_single/#d0e1622">InjectionPoint</a> metadata to set the proper value based on either the name of the attribute or the value of the annotation. This example will ensure that both:
[code lang="java"]
 @Inject @HttpParam(&quot;trackId&quot;)
 String currentTrackId;
[/code]
and
[code lang="java"]
 @Inject @HttpParam
 String trackId;
[/code]
Makes the request parameter "trackId" available to the field. Example url: http://www.glxn.net/listen?trackId=16180339 will set currentTrackId in the first example above to 16180339, and in the second set trackId to the same value.
[code lang="java"]
public class HttpParamProducer {

    @Inject
    FacesContext facesContext;

    @Produces
    @HttpParam
    String getHttpParameter(InjectionPoint ip) {
        String name = ip.getAnnotated().getAnnotation(HttpParam.class).value();
        if (&quot;&quot;.equals(name)) name = ip.getMember().getName();
        return facesContext.getExternalContext()
                .getRequestParameterMap()
                .get(name);
    }
}
[/code]
Now we can access the request parameter in our <a href="http://docs.jboss.org/weld/reference/1.0.1-Final/en-US/html_single/#bean-definition">Bean</a> simply by annotating the field with @Inject and @HttpParam. In the example below I am injecting the @SessionScoped bean SpotifyWeb, and calling its wrap method to enrich my request parameter "trackId" using a Producer method to create a @Named parameter "trackReqParam" available to another bean, or in my case the view. So in my view page i print out <strong>#{trackReqParam}</strong> and it shows the initial request parameter trackId with some modification done in the wrap method. Just a simple example of it's application. 
The key here is that you can't inject a request parameter to a session scoped bean and expect it to not live in the dependent scope of its parent. That means if you do inject it to a session scoped bean, it is injected and set once, then lives in that scope until the scope is terminated.
This enforces good design in my opinion. If you are using a session scoped bean and want values from it, it's variables and methods are readily available to a request scoped bean, so just inject it and do your work there. This ensures a slim application. 
[code lang="java"]
@RequestScoped
public class TrackProducer {

    @Inject @HttpParam
    String trackId;

    @Inject
    SpotifyWeb spotifyWeb;

    @Produces
    @Named(&quot;trackReqParam&quot;)
    String getTrack() {
        return spotifyWeb.wrap(trackId);
    }
}
[/code]

You may also want to look at <a href="http://relation.to/Bloggers/InjectionPointMetadataAPIForWebBeans">Injection point metadata API for Web Beans by Gavin King</a>
